# ============================================
# CI/CD Pipeline - PhishGuardAI
# Stages: test → build → deploy
# ============================================

stages:
  - test
  - build
  - deploy 

# ============================================
# Templates for Security Scanning
# ============================================
include:
  - template: Security/Secret-Detection.gitlab-ci.yml
  - template: Security/SAST.gitlab-ci.yml
  - template: Security/Dependency-Scanning.gitlab-ci.yml


# ============================================
# STAGE 1: Test , Lint , Security Scan, validate
# ============================================

# Note: secret_detection and sast jobs are automatically created by the included templates
# We don't need to redefine them here - the templates handle everything

test:backend-unit:
  stage: test
  image: python:3.12-slim
  before_script:
    - cd backend
    - pip install --no-cache-dir -r requirements.txt
    - pip install pytest pytest-cov pytest-asyncio httpx
  script:
    - echo "Running backend unit tests..."
    - pytest tests/ --cov=app --cov-report=xml:coverage.xml --cov-report=term --cov-report=html:htmlcov -v
    - echo "Backend tests completed"
    - ls -la coverage.xml htmlcov/ || echo "Coverage files generated"
  coverage: '/(?i)total.*? (100(?:\.0+)?\%|[1-9]?\d(?:\.\d+)?\%)$/'
  artifacts:
    when: always
    reports:
      coverage_report:
        coverage_format: cobertura
        path: backend/coverage.xml
    paths:
      - backend/coverage.xml
      - backend/htmlcov/
    expire_in: 1 week
  rules:
    - if: "$CI_MERGE_REQUEST_TARGET_BRANCH_NAME =~ /^(main|prod)$/ || $CI_COMMIT_BRANCH =~ /^(main|prod)$/"
  allow_failure: true

test:frontend-unit:
  stage: test
  image: node:20-alpine
  before_script:
    - cd frontend
    - npm ci --cache .npm --prefer-offline
  script:
    - echo "Running frontend unit tests..."
    - npm run test:coverage
    - echo "Frontend tests completed"
    - ls -la coverage/ || echo "Coverage directory created"
  cache:
    key: frontend-test-cache
    paths:
      - frontend/.npm
      - frontend/node_modules
  artifacts:
    when: always
    reports:
      coverage_report:
        coverage_format: cobertura
        path: frontend/coverage/cobertura-coverage.xml
    paths:
      - frontend/coverage/
    expire_in: 1 week
  rules:
    - if: "$CI_MERGE_REQUEST_TARGET_BRANCH_NAME =~ /^(main|prod)$/ || $CI_COMMIT_BRANCH =~ /^(main|prod)$/"
  allow_failure: true

test:docker-compose:
  stage: test
  image: docker:24-dind
  services:
    - docker:24-dind
  script:
    - echo "Testing Docker Compose configuration..."
    - docker compose config
    - echo "Docker Compose configuration is valid"
  rules:
    - if: "$CI_MERGE_REQUEST_TARGET_BRANCH_NAME =~ /^(main|prod)$/ || $CI_COMMIT_BRANCH =~ /^(main|prod)$/"
  allow_failure: true

test:terraform-test:
  stage: test
  image: docker:24-dind  
  services:
    - docker:24-dind  
  script:
    - cd infr/
    - docker compose run --rm terraform -chdir=prod/ init -backend=false
    - docker compose run --rm terraform -chdir=setup/ init -backend=false
    - docker compose run --rm terraform -chdir=setup/ validate
    - docker compose run --rm terraform -chdir=setup/ fmt -check
    - docker compose run --rm terraform -chdir=prod/ validate
    - docker compose run --rm terraform -chdir=prod/ fmt -check
  rules:
    - if: "$CI_MERGE_REQUEST_TARGET_BRANCH_NAME =~ /^(main|prod)$/ || $CI_COMMIT_BRANCH =~ /^(main|prod)$/"
  allow_failure: true

# ============================================
# STAGE 2: BUILD AND PUSH
# ============================================

build-images-push-to-ecr:
  stage: build
  image: docker:24-dind
  services:
    - docker:24-dind
  script:
    - apk update && apk add aws-cli
    - aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.us-east-1.amazonaws.com
    - docker build --compress -t $ecr_backend_repo_url:$CI_COMMIT_SHA ./backend
    - docker push $ecr_backend_repo_url:$CI_COMMIT_SHA
    - docker build --compress -t $ecr_frontend_repo_url:$CI_COMMIT_SHA ./frontend
    - docker push $ecr_frontend_repo_url:$CI_COMMIT_SHA
  rules:
    - if: $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "prod"
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: manual
  allow_failure: false

# ============================================
# STAGE 3: DEPLOY
# ============================================

deploy:staging:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache curl
  script:
    - echo "Deploying to staging environment..."
    - echo "Backend image - $BACKEND_IMAGE"
    - echo "Frontend image - $FRONTEND_IMAGE"
    - echo "Deployment preparation completed"
    - echo "DEPLOYMENT_URL=https://staging.phishguard.example.com" >> deploy.env
  environment:
    name: staging
    url: https://staging.phishguard.example.com
  artifacts:
    reports:
      dotenv: deploy.env
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_BRANCH == "develop"
      when: manual
  allow_failure: false

deploy:production:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache curl
  script:
    - echo "Deploying to production environment..."
    - echo "Backend image - $BACKEND_IMAGE"
    - echo "Frontend image - $FRONTEND_IMAGE"
    - echo "Production deployment preparation completed"
    - echo "DEPLOYMENT_URL=https://phishguard.example.com" >> deploy.env
  environment:
    name: production
    url: https://phishguard.example.com
  artifacts:
    reports:
      dotenv: deploy.env
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
  allow_failure: false

# ============================================
# Additional Jobs
# ============================================

cleanup:
  stage: deploy
  image: alpine:latest
  script:
    - echo "Cleaning up old artifacts..."
    - echo "Cleanup completed"
  when: on_success
  allow_failure: true
