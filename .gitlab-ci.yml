# ============================================
# CI/CD Pipeline - PhishGuardAI
# Stages: test → build → deploy
# ============================================

stages:
  - test
  - build
  - deploy 

# ============================================
# Templates for Security Scanning
# ============================================
include:
  - template: Security/Secret-Detection.gitlab-ci.yml
  - template: Security/SAST.gitlab-ci.yml
  - template: Security/Dependency-Scanning.gitlab-ci.yml


# ============================================
# STAGE 1: Test , Lint , Security Scan, validate
# ============================================

# Note: secret_detection and sast jobs are automatically created by the included templates
# We don't need to redefine them here - the templates handle everything

test:backend-unit:
  stage: test
  image: python:3.12-slim
  before_script:
    - cd backend
    - pip install --no-cache-dir -r requirements.txt
    - pip install pytest pytest-cov pytest-asyncio httpx
  script:
    - echo "Running backend unit tests..."
    - pytest tests/ --cov=app --cov-report=xml:coverage.xml --cov-report=term --cov-report=html:htmlcov -v
    - echo "Backend tests completed"
    - ls -la coverage.xml htmlcov/ || echo "Coverage files generated"
  coverage: '/(?i)total.*? (100(?:\.0+)?\%|[1-9]?\d(?:\.\d+)?\%)$/'
  artifacts:
    when: always
    reports:
      coverage_report:
        coverage_format: cobertura
        path: backend/coverage.xml
    paths:
      - backend/coverage.xml
      - backend/htmlcov/
    expire_in: 1 week
  rules:
    - if: "$CI_MERGE_REQUEST_TARGET_BRANCH_NAME =~ /^(main|prod)$/ || $CI_COMMIT_BRANCH =~ /^(main|prod)$/"
  allow_failure: true

test:frontend-unit:
  stage: test
  image: node:20-alpine
  before_script:
    - cd frontend
    - npm ci --cache .npm --prefer-offline
  script:
    - echo "Running frontend unit tests..."
    - npm run test:coverage
    - echo "Frontend tests completed"
    - ls -la coverage/ || echo "Coverage directory created"
  cache:
    key: frontend-test-cache
    paths:
      - frontend/.npm
      - frontend/node_modules
  artifacts:
    when: always
    reports:
      coverage_report:
        coverage_format: cobertura
        path: frontend/coverage/cobertura-coverage.xml
    paths:
      - frontend/coverage/
    expire_in: 1 week
  rules:
    - if: "$CI_MERGE_REQUEST_TARGET_BRANCH_NAME =~ /^(main|prod)$/ || $CI_COMMIT_BRANCH =~ /^(main|prod)$/"
  allow_failure: true

test:docker-compose:
  stage: test
  image: docker:24-dind
  services:
    - docker:24-dind
  script:
    - echo "Testing Docker Compose configuration..."
    - docker compose config
    - echo "Docker Compose configuration is valid"
  rules:
    - if: "$CI_MERGE_REQUEST_TARGET_BRANCH_NAME =~ /^(main|prod)$/ || $CI_COMMIT_BRANCH =~ /^(main|prod)$/"
  allow_failure: true

test:terraform-test:
  stage: test
  image: docker:24-dind  
  services:
    - docker:24-dind  
  script:
    - cd infr/
    - docker compose run --rm terraform -chdir=prod/ init -backend=false
    - docker compose run --rm terraform -chdir=setup/ init -backend=false
    - docker compose run --rm terraform -chdir=setup/ validate
    - docker compose run --rm terraform -chdir=setup/ fmt -check
    - docker compose run --rm terraform -chdir=prod/ validate
    - docker compose run --rm terraform -chdir=prod/ fmt -check
  rules:
    - if: "$CI_MERGE_REQUEST_TARGET_BRANCH_NAME =~ /^(main|prod)$/ || $CI_COMMIT_BRANCH =~ /^(main|prod)$/"
  allow_failure: true

# ============================================
# STAGE 2: BUILD AND PUSH
# ============================================

build-images-push-to-ecr:
  stage: build
  image: docker:24-dind
  services:
    - docker:24-dind
  variables:
    AWS_DEFAULT_REGION: us-east-1
  before_script:
    - apk update && apk add --no-cache aws-cli
    - echo "Verifying required variables..."
    - |
      MISSING_VARS=""
      [ -z "$AWS_ACCESS_KEY_ID" ] && MISSING_VARS="$MISSING_VARS AWS_ACCESS_KEY_ID"
      [ -z "$AWS_SECRET_ACCESS_KEY" ] && MISSING_VARS="$MISSING_VARS AWS_SECRET_ACCESS_KEY"
      [ -z "$AWS_ACCOUNT_ID" ] && MISSING_VARS="$MISSING_VARS AWS_ACCOUNT_ID"
      [ -z "$ecr_backend_repo_url" ] && MISSING_VARS="$MISSING_VARS ecr_backend_repo_url"
      [ -z "$ecr_frontend_repo_url" ] && MISSING_VARS="$MISSING_VARS ecr_frontend_repo_url"
      
      if [ -n "$MISSING_VARS" ]; then
        echo "ERROR: Missing required GitLab CI/CD variables:$MISSING_VARS"
        echo "Please add these variables in: Settings > CI/CD > Variables"
        exit 1
      fi
    - echo "All required variables are present"
  script:
    - echo "Logging into AWS ECR..."
    - aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.us-east-1.amazonaws.com
    - echo "Building backend image..."
    - docker build --compress -t $ecr_backend_repo_url:$CI_COMMIT_SHA ./backend
    - echo "Pushing backend image..."
    - docker push $ecr_backend_repo_url:$CI_COMMIT_SHA
    - echo "Building frontend image..."
    - docker build --compress -t $ecr_frontend_repo_url:$CI_COMMIT_SHA ./frontend
    - echo "Pushing frontend image..."
    - docker push $ecr_frontend_repo_url:$CI_COMMIT_SHA
    - echo "Build and push completed successfully"
  rules:
    - if: $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "prod"
  allow_failure: false

# ============================================
# STAGE 3: DEPLOY
# ============================================

deploy:infrastructure:
  stage: deploy
  image: docker:24-dind
  services:
    - docker:24-dind
  variables:
    AWS_DEFAULT_REGION: us-east-1
  before_script:
    - apk update && apk add --no-cache aws-cli
    - echo "Verifying required variables for deployment..."
    - |
      MISSING_VARS=""
      [ -z "$AWS_ACCESS_KEY_ID" ] && MISSING_VARS="$MISSING_VARS AWS_ACCESS_KEY_ID"
      [ -z "$AWS_SECRET_ACCESS_KEY" ] && MISSING_VARS="$MISSING_VARS AWS_SECRET_ACCESS_KEY"
      [ -z "$AWS_ACCOUNT_ID" ] && MISSING_VARS="$MISSING_VARS AWS_ACCOUNT_ID"
      
      if [ -n "$MISSING_VARS" ]; then
        echo "ERROR: Missing required GitLab CI/CD variables:$MISSING_VARS"
        exit 1
      fi
  script:
    - |
      if [[ $CI_COMMIT_BRANCH == 'prod' ]]; then
        workspace="prod"
      else
        workspace="staging"
      fi
    - export TF_VAR_ecr_app_image="$ecr_backend_repo_url:$CI_COMMIT_SHA"
    - export TF_VAR_ecr_proxy_image="$ecr_frontend_repo_url:$CI_COMMIT_SHA"
    - cd infr/prod
    - docker compose run --rm terraform init
    - docker compose run --rm terraform workspace select -or-create $workspace
    - docker compose run --rm terraform plan
    - docker compose run --rm terraform apply -auto-approve
    - export LB_DNS=$(docker compose run --rm terraform output -raw load_balancer_dns)
    - export S3_BUCKET=$(docker compose run --rm terraform output -raw s3_bucket_name)
    - export CF_DIST_ID=$(docker compose run --rm terraform output -raw cloudfront_distribution_id)
    - export FRONTEND_URL=$(docker compose run --rm terraform output -raw frontend_url)
    - echo "S3_BUCKET=${S3_BUCKET}" >> /tmp/deploy.env
    - echo "CF_DIST_ID=${CF_DIST_ID}" >> /tmp/deploy.env
    - cd ../../frontend
    - npm install
    - npm run build
    - aws s3 sync dist/ "s3://${S3_BUCKET}/" --delete
    - aws cloudfront create-invalidation --distribution-id "${CF_DIST_ID}" --paths "/*"
    - echo "Frontend deployed and CloudFront invalidated"
  artifacts:
    reports:
      dotenv: /tmp/deploy.env
  rules:
    - if: $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "prod"
      when: manual
  allow_failure: false

# ============================================
# Additional Jobs
# ============================================

cleanup:
  stage: deploy
  image: alpine:latest
  script:
    - echo "Cleaning up old artifacts..."
    - echo "Cleanup completed"
  when: on_success
  allow_failure: true

destroy:infrastructure:
  stage: deploy
  image: docker:24-dind
  services:
    - docker:24-dind
  variables:
    AWS_DEFAULT_REGION: us-east-1
  before_script:
    - apk update && apk add --no-cache aws-cli
    - echo "Verifying required variables for destroy..."
    - |
      MISSING_VARS=""
      [ -z "$AWS_ACCESS_KEY_ID" ] && MISSING_VARS="$MISSING_VARS AWS_ACCESS_KEY_ID"
      [ -z "$AWS_SECRET_ACCESS_KEY" ] && MISSING_VARS="$MISSING_VARS AWS_SECRET_ACCESS_KEY"
      
      if [ -n "$MISSING_VARS" ]; then
        echo "ERROR: Missing required GitLab CI/CD variables:$MISSING_VARS"
        exit 1
      fi
  script:
    - |
      if [[ $CI_COMMIT_BRANCH == 'prod' ]]; then
        workspace="prod"
      else
        workspace="staging"
      fi
    - cd infr/prod
    - docker compose run --rm terraform init
    - docker compose run --rm terraform workspace select $workspace
    - docker compose run --rm terraform plan -destroy
    - docker compose run --rm terraform destroy -auto-approve
  rules:
    - if: $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "prod"
      when: manual
  allow_failure: false